# Luogu p1002 - 过河卒 \[NOIP2022普及组\]

## $1$ 这真的是一道路径搜索题吗？ 

### $1.1$ DFS解法

不要被这个小标题吓到了，我们先试着用DFS完整解决这道题吧。套用DFS的基本模型，不难想出下面的伪代码：
```c++
int n,m; //终点坐标
int ctrlPts[9][2]; //马及其控制点坐标
int answer = 0;

void dfs(int x,int y)
{
    if(x == n && y == m) //找到到达B点的路径
    {
        answer++;
        return;
    }
    for (Direction D to be 'right' or 'down') //尝试向右或者向下走
    {
        int nx,ny => go D from (x,y) to (nx,ny);
        if (isGoodPoint(nx, ny))
        {
            dfs(nx, ny);
        }
    }
}

int main()
{
    int horseX, horseY;
    scanf("%d%d%d%d", &n, &m, &horseX, &horseY);
    calculateCtrlPts(horseX, horseY); //计算马的控制点
    dfs(0, 0);
    printf("%d\n", answer);
    return 0;
}
```

接下来便是实现`calculateCtrlPts(x,y)`和`isGoodPoint(x,y)`两个函数。首先是`isGoodPoint(x,y)`，需要判断三点：
- $(x,y)$没有越界（`x>=0 && y>=0 && x<=n && y<=m`）；
- $(x,y)$不是控制点之一；
- 在当前搜索的路径中，$(x,y)$没有在“足迹”里重复出现（否则可能会造成死循环）。 [^注1] 笔者这里使用了一个`bool book[21][21]`数组来标记目前卒已经走过的路径。还需注意一点，“足迹”只考虑当前搜索中的路径，因此每尝试完一个方向后要将标记撤回再进行下一次尝试。
```c++
bool book[21][21] = {0}; // book[x][y] => 当前路径中已经走过了(x,y)
...
bool isGoodPoint(int x, int y) // 利用return的短路特性，避免if-else嵌套，更加简洁
{
    if (book[x][y])
        return false;
    if (x < 0 || y < 0 || x > n || y > m)
        return false;
    for (int i = 0; i < 9; i++)
    {
        if (ctrlPts[i][0] == x && ctrlPts[i][1] == y)
            return false;
    }
    return true;
}
```

接下来是`calculateCtrlPts(x,y)`，为了节省代码量，我们可以巧用**常量表**配合循环。笔者在这里利用二维数组`const int CtrlPtDlt[9][2]`来记录所有9个控制点与马的坐标的相对位置：
```c++
const int CtrlPtDlt[9][2] = {
    {-2, -1}, {-2,  1}, {-1, -2}, 
    { 0,  0}, {-1,  2}, { 1, -2}, 
    { 1,  2}, { 2, -1}, { 2,  1}};
```

之后只要使用马的坐标就可以依次计算出9个控制点的坐标：
```c++
int ctrlPts[9][2]; // 控制点
const int CtrlPtDlt[9][2] = { // 控制点相对位置
    {-2, -1}, {-2,  1}, {-1, -2}, 
    { 0,  0}, {-1,  2}, { 1, -2}, 
    { 1,  2}, { 2, -1}, { 2,  1}};
...
void calculateCtrlPts(int horseX, int horseY)
{
    for (int i = 0; i < 9; i++)
    {
        ctrlPts[i][0] = horseX + CtrlPtDlt[i][0];
        ctrlPts[i][1] = horseY + CtrlPtDlt[i][1];
    }
}
```
实际上，枚举向下走和向右走也可以用常量表实现。从$(x,y)$出发，向右走一步为$(x,y+1)$，向下一步为$(x+1,y)$，与原来的点的相对位置可以分别表示为$(0,+1)$，$(+1,0)$。结合这一点，不难给出`dfs(x,y)`函数的完整实现：
```c++
const int Dir[2][2] = {{0, 1}, {1, 0}}; //向下走和向右走
...
void dfs(int x, int y)
{
    if (x == n && y == m)
    {
        answer++;
        return;
    }
    for (int i = 0; i < 2; i++)
    {
        int nx, ny;
        nx = x + Dir[i][0];
        ny = y + Dir[i][1];
        if (isGoodPoint(nx, ny))
        {
            book[nx][ny] = true; // 在当前的路径中标记“脚印”
            dfs(nx, ny);
            book[nx][ny] = false; // 收回“脚印”的标记
        }
    }
    return;
}
```

将上述所有函数、变量和`main()`函数结合在一起就得到了完整的题解代码。

[^注1]: 实际上本题可以不需要考虑，因为卒只能向下或向右走，一定不会回到原来的“足迹”

### $1.2$ 绝对不简单

读者可以尝试自己实现 ~~复制~~ 上述题解并提交，得到的结果却是惨重的——5个测试点有3个超时！或者我们可以自己在本地进行测试。输入`17 16 3 3`，程序的确得出了正确结果`38969475`，但在笔者的机器上花费了3.5s的时间运行！题目说明中给出$1<=n,m<=20$，这是合法的输入，不难预测到超时的结果。

*这河里吗？为什么会这样？*

让我们再回过头来分析算法。思考：假设不考虑马和控制点，从$(0,0)$到任意点$(x,y)$的路径可能有多少条？不需要计算出精确的公式，但读者不妨自己用笔和网格纸模拟一下，依次取由小到大的几组$x$和$y$，可以发现：答案随着$x$和$y$的增大是呈**爆炸性增长**的。读者也可以由上面输入的样例数据得出的千万数量级的答案体会到这一点。我们的程序却要依次遍历其中的每一种路径，运算的量级可想而知。

看来依次遍历所有路径的方法是走不通了，我们需要更加抽象的模型才能提高解题的效率。

## $2$ 如何才能优化？

### $2.1$ 抽象一点...

我们先来看一个简单的问题：平面上有四个点$\{(x,y)|x,y\in\{0,1\}\}$，或者说$(0,0),(0,1),(1,0),(1,1)$，从$(0,0)$到$(1,1)$共有几条路径（依然只能向下或向右走）？

![p2.1.1](somePicture)

答案显然是$2$。但你是怎么得出这个答案的呢？ ~~一眼秒出？~~ 或许我们可以采用下面的思考模式：

>1. 从$(1,1)$来看，有两条*可能*的路径可以到达目的地：$(0,1)$和$(1,0)$；
>
>2. 先来看$(0,1)$，只有起点$(0,0)$可以到达，因此*确定*的路径数为1；
>
>3. 再看$(1,0)$，还是只有起点$(0,0)$可以到达，*确定*的路径数也是1；
>
>4. 分别从$(0,1)$和$(1,0)$出发，都可以畅通无阻地到达$(1,1)$。从起点$(0,0)$到这两个点的*确定*的路径数都是$1$，也就是说，从起点出发，一共有$1+1=2$条路径可以到达$(1,1)$点。

我们试着将$(0,0)$和$(1,1)$两个具体的点换成更一般的点：

1 从$(a,b)$来看，有两条*可能*的路径可以到达目的地：$(a-1,b)$和$(a,b-1)$；

2 先来看$(a-1,b)$，有两条*可能*的路径可以到达：$(a-2,b)$和$(a-1,a-1)$；

  2.1. 继续考虑$(a-2,b)$...
  
  2.2.

3 再看$(1,0)$，还是只有起点$(0,0)$可以到达，*确定*的路径数也是1；

4 分别从$(a-1,b)$和$(a,b-1)$出发，都可以畅通无阻地到达$(a,b)$。从起点$(0,0)$到这两个点的*确定*的路径数分别是$p_1$和$p_2$，也就是说，从起点出发，一共有$p_1+p_2$条路径可以到达$(a,b)$点。



